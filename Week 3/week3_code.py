# -*- coding: utf-8 -*-
"""week3_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G-P_XGR7cSJ2jqYWAdHsx-KBvZdAelEn
"""

#Importing necessay libraries and modules
import numpy as np
import scipy.special as sp 
from pylab import * 
from scipy import linalg
FILENAME = "fitting.dat"

"""### QUESTION 1"""

#Ran the generate_data.py to get the fitting.dat file created

"""### QUESTION 2"""

data = np.loadtxt(FILENAME) #Loading data
#Initializing variables
yy = data[:,1:]
t = data[:,0]
k = data.shape[1] - 1
sigma = logspace(-1,-3,k)

"""### QUESTION 3 & 4"""

def g(t, A = 1.05, B = -0.105): #Noise less function
    return A * sp.jn(2, t) + B*t


y_t = list(map(g, t)) #Noiseless values
#Plotting
figure(figsize=(10,8))
plot(t,yy, label = sigma)
plot(t, y_t, label = "True Value", color = "k")
legend([f"$\sigma_{i + 1}$ = {sig:.3f}" for i, sig in enumerate(sigma)] + ["True value"])
xlabel(r'$t\rightarrow$',size=20)
ylabel(r'$f(t)+noise\rightarrow$',size=20)
title("Q4: Data to be fitted to theory", size=20)
grid(True)
show()

"""### QUESTION 5"""

#plotting
figure(figsize=(10,8))
plot(t, y_t, color = "k")
errorbar(t[::5],yy[::5,0],sigma[0],fmt="ro")#yerr = sigma
legend(["True Value", "Error Bars"])
xlabel(r'$t\rightarrow$',size=20)
ylabel(r'$f(t)+noise\rightarrow$',size=20)
title("Q5: Data points for $\sigma = 0.10$ along with exact function", size=20)
grid(True)
show()

"""### QUESTION 6"""

A, B = 1.05, -0.105 #Best Fit for no noise
Js = np.apply_along_axis(lambda x: sp.jn(2, x), axis = 0, arr = t)
M = c_[Js, t] #Getting M matrix
Gs = np.apply_along_axis(g, axis = 0, arr = t).reshape(-1,1)
#Checking if matrixes are equal
if np.allclose(np.matmul(M, np.array([A, B]).reshape(2,1)), Gs):
    print("The vectors are same")
else:
    assert False, "The vectors are not equal"

"""### QUESTION 7"""

#Calculating MSE for 1st and 2nd columns
A = np.linspace(0, 2, 21).tolist()
B = np.linspace(-0.2, 0, 21).tolist()
e = np.zeros((2,21,21))
print(t.shape)
for _ in range(2):
    for i in range(21):
        for j in range(21):
            Gs = np.apply_along_axis(lambda x: g(x,A[i],B[j]), axis = 0, arr = t)
            e[_][i][j] += 1/101*np.sum((yy[:,_] - Gs)**2, axis = 0)

"""### QUESTION 8"""

x_a, y_a = linalg.lstsq(M, yy[:,0])[0] #Best fit for column 1
#Plptting
figure(figsize=(10,8))
clabel(contour(A,B,e[0], 10))
plot(x_a, y_a, marker = "o", markerfacecolor="red")
annotate("Exact Loaction", (x_a, y_a))
xlabel(r'$A\rightarrow$',size=20)
ylabel(r'$B\rightarrow$',size=20)
title("Q8: Contour plot of $\epsilon_{ij}$", size=20)
grid(True)
show()

"""### QUESTION 9"""

Gs = np.apply_along_axis(g, axis = 0, arr = t).reshape(-1,1)
GroundTruth = linalg.lstsq(M, Gs)[0]#No noise best fit
x = np.zeros((yy.shape[1], 2))
for i in range(yy.shape[1]):
    x[i] = linalg.lstsq(M, yy[:,i])[0] #Storing best fit for every column
print(f"The best estimate of A and B for 1st column is {x[0][0]:.4f} & {x[0][1]:.4f} respectively.")

"""### QUESTION 10"""

err_a = np.zeros((yy.shape[1])) #Storing A errors
err_b = np.zeros((yy.shape[1])) #Storing B errors
#Euclidean distance
for i in range(yy.shape[1]):
    err_a[i] += ((x[i][0] - GroundTruth[0])**2)**0.5 
    err_b[i] += ((x[i][1] - GroundTruth[1])**2)**0.5
#Plotting in linear scale
figure(figsize=(10,8))
plot(sigma,err_a, label = "Aerr", marker = "o", linestyle="dashed", alpha = 0.7)
plot(sigma, err_b, label = "Berr", marker = "o", linestyle="dashed", alpha = 0.7)
xlabel(r'$\sigma\rightarrow$',size=20)
ylabel(r'$Error(Euclidian)\rightarrow$',size=20)
legend()
title("Q10: Variation of error with noise", size=20)
grid(True)
show()

"""### QUESTION 11"""

#Plotting in log scale
figure(figsize=(10,8))
errorbar(sigma, err_a, sigma,fmt="ro", label = "Aerr")
errorbar(sigma, err_b, sigma, fmt = "go", label = "Berr")
xlabel(r'$\sigma\rightarrow$',size=20)
ylabel(r'$Error(Euclidian)\rightarrow$',size=20)
yscale("log")
xscale("log")
legend()
title("Q11: Variation of error with noise", size=20)
grid(True)
show()